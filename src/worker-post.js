///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// name: chucknode-post.js
// desc: emscripten binding agent for web assembly compilation / js code
//       for WebChucK as a web worker
//        
//       Adapted from Jack Atherton's 2017 implementation of WebChucK and 
//       combined with the SharedBufferWorkletProcessor implementation from
//       Chrome Web Audio Samples.
//
// author: terry feng (tzfeng@ccrma.stanford.edu)
//         Andrew Aday (azaday@stanford.edu)
// date:   May 2024 (original 4/19/17)

//-------------------------- wasm-audio-helper.js -----------------------------
/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
//-----------------------------------------------------------------------------

// Basic byte unit of WASM heap. (16 bit = 2 bytes)
const BYTES_PER_UNIT = Uint16Array.BYTES_PER_ELEMENT;

// Byte per audio sample. (32 bit float)
const BYTES_PER_SAMPLE = Float32Array.BYTES_PER_ELEMENT;

// The max audio channel on Chrome is 32.
const MAX_CHANNEL_COUNT = 32;

// WebAudio's render quantum size.
const RENDER_QUANTUM_FRAMES = 128;


/**
 * A WASM HEAP wrapper for AudioBuffer class. This breaks down the AudioBuffer
 * into an Array of Float32Array for the convinient WASM opearion.
 *
 * @class
 * @dependency Module A WASM module generated by the emscripten glue code.
 */
class HeapAudioBuffer {
  /**
   * @constructor
   * @param  {object} wasmModule WASM module generated by Emscripten.
   * @param  {number} length Buffer frame length.
   * @param  {number} channelCount Number of channels.
   * @param  {number} maxChannelCount Maximum number of channels.
   */
  constructor(wasmModule, length, channelCount, maxChannelCount) {
    // The |channelCount| must be greater than 0, and less than or equal to
    // the maximum channel count.
    this._isInitialized = false;
    this._module = wasmModule;
    this._length = length;
    this._maxChannelCount = maxChannelCount
        ? Math.min(maxChannelCount, MAX_CHANNEL_COUNT)
        : channelCount;
    this._channelCount = channelCount;
    this._allocateHeap();
    this._isInitialized = true;
  }

  /**
   * Allocates memory in the WASM heap and set up Float32Array views for the
   * channel data.
   *
   * @private
   */
  _allocateHeap() {
    const channelByteSize = this._length * BYTES_PER_SAMPLE;
    const dataByteSize = this._channelCount * channelByteSize;
    this._dataPtr = this._module._malloc(dataByteSize);
    this._channelData = [];
    for (let i = 0; i < this._channelCount; ++i) {
      let startByteOffset = this._dataPtr + i * channelByteSize;
      let endByteOffset = startByteOffset + channelByteSize;
      // Get the actual array index by dividing the byte offset by 2 bytes.
      this._channelData[i] =
          this._module.HEAPF32.subarray(startByteOffset >> BYTES_PER_UNIT,
                                        endByteOffset >> BYTES_PER_UNIT);
    }
  }

  /**
   * Adapt the current channel count to the new input buffer.
   *
   * @param  {number} newChannelCount The new channel count.
   */
  adaptChannel(newChannelCount) {
    if (newChannelCount < this._maxChannelCount) {
      this._channelCount = newChannelCount;
    }
    // reform subArrays just in case memory has grown since we last did this
    const channelByteSize = this._length * BYTES_PER_SAMPLE;
    for (let i = 0; i < this._channelCount; ++i) 
    {
      let startByteOffset = this._dataPtr + i * channelByteSize;
      let endByteOffset = startByteOffset + channelByteSize;
      // Get the actual array index by dividing the byte offset by 2 bytes.
      this._channelData[i] =
          this._module.HEAPF32.subarray(startByteOffset >> BYTES_PER_UNIT,
                                        endByteOffset >> BYTES_PER_UNIT);
    }
  }

  /**
   * Getter for the buffer length in frames.
   *
   * @return {?number} Buffer length in frames.
   */
  get length() {
    return this._isInitialized ? this._length : null;
  }

  /**
   * Getter for the number of channels.
   *
   * @return {?number} Buffer length in frames.
   */
  get numberOfChannels() {
    return this._isInitialized ? this._channelCount : null;
  }

  /**
   * Getter for the maxixmum number of channels allowed for the instance.
   *
   * @return {?number} Buffer length in frames.
   */
  get maxChannelCount() {
    return this._isInitialized ? this._maxChannelCount : null;
  }

  /**
   * Returns a Float32Array object for a given channel index. If the channel
   * index is undefined, it returns the reference to the entire array of channel
   * data.
   *
   * @param  {number|undefined} channelIndex Channel index.
   * @return {?Array} a channel data array or an
   * array of channel data.
   */
  getChannelData(channelIndex) {
    if (channelIndex >= this._channelCount) {
      return null;
    }
    return typeof channelIndex === 'undefined'
        ? this._channelData : this._channelData[channelIndex];
  }

  /**
   * Returns the base address of the allocated memory space in the WASM heap.
   *
   * @return {number} WASM Heap address.
   */
  getHeapAddress() {
    return this._dataPtr;
  }

  /**
   * Frees the allocated memory space in the WASM heap.
   */
  free() {
    this._isInitialized = false;
    this._module._free(this._dataPtr);
    this._module._free(this._pointerArrayPtr);
    this._channelData = null;
  }
} // class HeapAudioBuffer


/**
 * A JS FIFO implementation for the AudioWorklet. 3 assumptions for the
 * simpler operation:
 *  1. the push and the pull operation are done by 128 frames. (Web Audio
 *    API's render quantum size in the speficiation)
 *  2. the channel count of input/output cannot be changed dynamically.
 *    The AudioWorkletNode should be configured with the `.channelCount = k`
 *    (where k is the channel count you want) and
 *    `.channelCountMode = explicit`.
 *  3. This is for the single-thread operation. (obviously)
 *
 * @class
 */
class RingBuffer {
  /**
   * @constructor
   * @param  {number} length Buffer length in frames.
   * @param  {number} channelCount Buffer channel count.
   */
  constructor(length, channelCount) {
    this._readIndex = 0;
    this._writeIndex = 0;
    this._framesAvailable = 0;

    this._channelCount = channelCount;
    this._length = length;
    this._channelData = [];
    for (let i = 0; i < this._channelCount; ++i) {
      this._channelData[i] = new Float32Array(length);
    }
  }

  /**
   * Getter for Available frames in buffer.
   *
   * @return {number} Available frames in buffer.
   */
  get framesAvailable() {
    return this._framesAvailable;
  }

  /**
   * Push a sequence of Float32Arrays to buffer.
   *
   * @param  {array} arraySequence A sequence of Float32Arrays.
   */
  push(arraySequence) {
    // The channel count of arraySequence and the length of each channel must
    // match with this buffer obejct.

    // Transfer data from the |arraySequence| storage to the internal buffer.
    let sourceLength = arraySequence[0].length;
    for (let i = 0; i < sourceLength; ++i) {
      let writeIndex = (this._writeIndex + i) % this._length;
      for (let channel = 0; channel < this._channelCount; ++channel) {
        this._channelData[channel][writeIndex] = arraySequence[channel][i];
      }
    }

    this._writeIndex += sourceLength;
    if (this._writeIndex >= this._length) {
      this._writeIndex = 0;
    }

    // For excessive frames, the buffer will be overwritten.
    this._framesAvailable += sourceLength;
    if (this._framesAvailable > this._length) {
      this._framesAvailable = this._length;
    }
  }

  /**
   * Pull data out of buffer and fill a given sequence of Float32Arrays.
   *
   * @param  {array} arraySequence An array of Float32Arrays.
   */
  pull(arraySequence) {
    // The channel count of arraySequence and the length of each channel must
    // match with this buffer obejct.

    // If the FIFO is completely empty, do nothing.
    if (this._framesAvailable === 0) {
      return;
    }

    let destinationLength = arraySequence[0].length;

    // Transfer data from the internal buffer to the |arraySequence| storage.
    for (let i = 0; i < destinationLength; ++i) {
      let readIndex = (this._readIndex + i) % this._length;
      for (let channel = 0; channel < this._channelCount; ++channel) {
        arraySequence[channel][i] = this._channelData[channel][readIndex];
      }
    }

    this._readIndex += destinationLength;
    if (this._readIndex >= this._length) {
      this._readIndex = 0;
    }

    this._framesAvailable -= destinationLength;
    if (this._framesAvailable < 0) {
      this._framesAvailable = 0;
    }
  }
} // class RingBuffer


// ------------------------------------------------------------------------ //
// ------------------------------------------------------------------------ //
// --------------------------- chucknode.js ------------------------------- //
// ------------------------------------------------------------------------ //
// ------------------------------------------------------------------------ //

// Initialization and cleanup
let setDataDir, setLogLevel, initChuckInstance, clearChuckInstance,
    clearGlobals, cleanupChuckInstance, cleanRegisteredChucks;
// Running and replacing Chuck code
let runChuckCode, runChuckCodeWithReplacementDac, runChuckFile,
    runChuckFileWithReplacementDac, runChuckFileWithArgs,
    runChuckFileWithArgsWithReplacementDac,
    replaceChuckCode, replaceChuckCodeWithReplacementDac,
    replaceChuckFile, replaceChuckFileWithReplacementDac,
    replaceChuckFileWithArgs, replaceChuckFileWithArgsWithReplacementDac;
// Shred management
let isShredActive, removeShred;
// Global variables
let setChuckInt, getChuckInt, setChuckFloat, getChuckFloat,
    setChuckString, getChuckString;
// Global events
let signalChuckEvent, broadcastChuckEvent, listenForChuckEventOnce,
    startListeningForChuckEvent, stopListeningForChuckEvent;

// Global arrays
let getGlobalIntArray, setGlobalIntArrayValue, getGlobalIntArrayValue,
    setGlobalAssociativeIntArrayValue, getGlobalAssociativeIntArrayValue,
    getGlobalFloatArray, setGlobalFloatArrayValue, getGlobalFloatArrayValue,
    setGlobalAssociativeFloatArrayValue, getGlobalAssociativeFloatArrayValue;
// VM parameters
let setParamInt, setParamFloat, setParamString,
    getParamInt, getParamFloat, getParamString;
// Time
let getChuckNow;


let initGlobals = function( Module )
{
  // metaproperties (e.g. setDataDir must be called before init_chuck
  setDataDir = Module.cwrap( 'setDataDir', 'number', ['string'] );
  setLogLevel = Module.cwrap( 'setLogLevel', 'number', ['number'] );

  // initialize a chuck VM
  initChuckInstance = Module.cwrap( 'initChuckInstance', 'number', ['number', 'number', 'number', 'number'] );

  // cleanup 
  clearChuckInstance = Module.cwrap( 'clearChuckInstance', 'number', ['number'] );
  clearGlobals = Module.cwrap( 'clearGlobals', 'number', ['number'] );
  cleanupChuckInstance = Module.cwrap( 'cleanupChuckInstance', 'number', ['number'] );
  cleanRegisteredChucks = Module.cwrap( 'cleanRegisteredChucks', null );

  // running code 
  runChuckCode = Module.cwrap( 'runChuckCode', 'number', ['number', 'string'] );
  runChuckCodeWithReplacementDac = Module.cwrap( 'runChuckCodeWithReplacementDac', 'number', ['number', 'string', 'string'] );
  runChuckFile = Module.cwrap( 'runChuckFile', 'number', ['number', 'string'] );
  runChuckFileWithReplacementDac = Module.cwrap( 'runChuckFileWithReplacementDac', 'number', ['number', 'string', 'string'] );
  runChuckFileWithArgs = Module.cwrap( 'runChuckFileWithArgs', 'number', ['number', 'string', 'string'] );
  runChuckFileWithArgsWithReplacementDac = Module.cwrap( 'runChuckFileWithArgsWithReplacementDac', 'number', ['number', 'string', 'string', 'string'] );
  
  replaceChuckCode = Module.cwrap( 'replaceChuckCode', 'number', ['number', 'number', 'string'] );
  replaceChuckCodeWithReplacementDac = Module.cwrap( 'replaceChuckCodeWithReplacementDac', 'number', ['number', 'number', 'string', 'string'] );
  replaceChuckFile = Module.cwrap( 'replaceChuckFile', 'number', ['number', 'number', 'string'] );
  replaceChuckFileWithReplacementDac = Module.cwrap( 'replaceChuckFileWithReplacementDac', 'number', ['number', 'number', 'string', 'string'] );
  replaceChuckFileWithArgs = Module.cwrap( 'replaceChuckFileWithArgs', 'number', ['number', 'number', 'string', 'string'] );
  replaceChuckFileWithArgsWithReplacementDac = Module.cwrap( 'replaceChuckFileWithArgsWithReplacementDac', 'number', ['number', 'number', 'string', 'string', 'string'] );
  
  // shred management
  isShredActive = Module.cwrap( 'isShredActive', 'number', ['number', 'number'] );
  removeShred = Module.cwrap( 'removeShred', 'number', ['number', 'number'] );

  // set/get global int, float, string
  setChuckInt = Module.cwrap( 'setChuckInt', 'number', ['number', 'string', 'number'] );
  getChuckInt = Module.cwrap( 'getChuckInt', 'number', ['number', 'string'] );
  setChuckFloat = Module.cwrap( 'setChuckFloat', 'number', ['number', 'string', 'number'] );
  getChuckFloat = Module.cwrap( 'getChuckFloat', 'number', ['number', 'string'] );
  setChuckString = Module.cwrap( 'setChuckString', 'number', ['number', 'string', 'string'] );
  getChuckString = Module.cwrap( 'getChuckString', 'number', ['number', 'string', 'number'] );

  // global Events
  signalChuckEvent = Module.cwrap( 'signalChuckEvent', 'number', ['number', 'string'] );
  broadcastChuckEvent = Module.cwrap( 'broadcastChuckEvent', 'number', ['number', 'string'] );
  listenForChuckEventOnce = Module.cwrap( 'listenForChuckEventOnce', 'number', ['number', 'string', 'number'] );
  startListeningForChuckEvent = Module.cwrap( 'startListeningForChuckEvent', 'number', ['number', 'string', 'number']);
  stopListeningForChuckEvent = Module.cwrap( 'stopListeningForChuckEvent', 'number', ['number', 'string', 'number']);

  // note: array is SAMPLE == Float32
  // NOTE: anything using arrays cannot use cwrap; use in similar manner to Module._chuckManualAudioCallback
  // TODO:
  // getGlobalUGenSamples = Module.cwrap( 'getGlobalUGenSamples', 'number', ['number', 'string', 'array', 'number'] );

  // set/get global int arrays
  // note: anything using arrays cannot use cwrap (since 'array' is an Int64Array)
  // called manually with heap manipulation below
  // setGlobalIntArray = Module.cwrap( 'setGlobalIntArray', 'number', ['number', 'string', 'array', 'number'] );
  getGlobalIntArray = Module.cwrap( 'getGlobalIntArray', 'number', ['number', 'string', 'number'] );
  setGlobalIntArrayValue = Module.cwrap( 'setGlobalIntArrayValue', 'number', ['number', 'string', 'number', 'number'] );
  getGlobalIntArrayValue = Module.cwrap( 'getGlobalIntArrayValue', 'number', ['number', 'string', 'number'] );
  setGlobalAssociativeIntArrayValue = Module.cwrap( 'setGlobalAssociativeIntArrayValue', 'number', ['number', 'string', 'string', 'number'] );
  getGlobalAssociativeIntArrayValue = Module.cwrap( 'getGlobalAssociativeIntArrayValue', 'number', ['number', 'string', 'string'] );

  // set/get global float arrays
  // note: anything using arrays cannot use cwrap. called manually with heap manipulation below
  //  setGlobalFloatArray = Module.cwrap( 'setGlobalFloatArray', 'number', ['number', 'string', 'array', 'number'] );
  getGlobalFloatArray = Module.cwrap( 'getGlobalFloatArray', 'number', ['number', 'string', 'number'] );
  setGlobalFloatArrayValue = Module.cwrap( 'setGlobalFloatArrayValue', 'number', ['number', 'string', 'number', 'number'] );
  getGlobalFloatArrayValue = Module.cwrap( 'getGlobalFloatArrayValue', 'number', ['number', 'string', 'number'] );
  setGlobalAssociativeFloatArrayValue = Module.cwrap( 'setGlobalAssociativeFloatArrayValue', 'number', ['number', 'string', 'string', 'number'] );
  getGlobalAssociativeFloatArrayValue = Module.cwrap( 'getGlobalAssociativeFloatArrayValue', 'number', ['number', 'string', 'string'] );

  // set and get VM params | 1.5.0.8 (ge) added
  setParamInt = Module.cwrap( 'setParamInt', 'number', ['number', 'string', 'number'] );
  setParamFloat = Module.cwrap( 'setParamFloat', 'number', ['number', 'string', 'number'] );
  setParamString = Module.cwrap( 'setParamString', 'number', ['number', 'string', 'string'] );
  getParamInt = Module.cwrap( 'getParamInt', 'number', ['number', 'string'] );
  getParamFloat = Module.cwrap( 'getParamFloat', 'number', ['number', 'string'] );
  getParamString = Module.cwrap( 'getParamString', 'string', ['number', 'string'] );

  // get current time | 1.5.0.8
  getChuckNow = Module.cwrap( 'getChuckNow', 'number', ['number'] );

  // set data dir to "/" for embedded files
  setDataDir( "/" );
}

//--------------------- shared-array-buffer-worker.js -------------------------
/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
//-----------------------------------------------------------------------------

// This Worker is the actual backend of AudioWorkletProcessor (AWP). After
// instantiated/initialized by AudioWorkletNode (AWN), it communicates with the
// associated AWP via SharedArrayBuffer (SAB).
//
// A pair of SABs is created by this Worker. The one is for the shared states
// (Int32Array) of ring buffer between two obejcts and the other works like the
// ring buffer for audio content (Float32Array).
//
// The synchronization mechanism between two object is done by wake/wait
// function in Atomics API. When the ring buffer runs out of the data to
// consume, the AWP will flip |REQUEST_RENDER| state to signal the worker. The
// worker wakes on the signal and renders the audio data requested.

// Indices for the State SAB.
const STATE = {
  // Flag for Atomics.wait() and notify().
  'REQUEST_RENDER': 0,
  // Available frames in Input SAB.
  'IB_FRAMES_AVAILABLE': 1,
  // Read index of Input SAB.
  'IB_READ_INDEX': 2,
  // Write index of Input SAB.
  'IB_WRITE_INDEX': 3,
  // Available frames in Output SAB.
  'OB_FRAMES_AVAILABLE': 4,
  // Read index of Output SAB.
  'OB_READ_INDEX': 5,
  // Write index of Output SAB.
  'OB_WRITE_INDEX': 6,
  // Size of Input and Output SAB.
  'RING_BUFFER_LENGTH': 7,
  // Size of user-supplied processing callback.
  'KERNEL_LENGTH': 8,
};

// Worker processor config.
const CONFIG = {
  bytesPerState: Int32Array.BYTES_PER_ELEMENT,
  bytesPerSample: Float32Array.BYTES_PER_ELEMENT,
  stateBufferLength: 16,
  ringBufferLength: 4096,
  // TODO: @tzfeng @azaday 
  // kernelLength: RENDER_QUANTUM_FRAMES,
  kernelLength: 1024,
  channelCount: 1,
  waitTimeOut: 25000,
  sampleRate: 44100,
};

// Shared states between this worker and AWP.
let States;

// Shared RingBuffers between this worker and AWP.
let InputRingBuffer;
let OutputRingBuffer;


//------------------------------------------------------
// WebChucK Worker Globals by @tzfeng
//------------------------------------------------------
const CHUCK_ID = 1; // Chuck ID
let _chuckWasmModule = undefined; // Module
let _heapInputBuffer = undefined; // HeapAudioBuffer
let _heapOutputBuffer = undefined; // HeapAudioBuffer
let _myActiveShreds = []; // Active shreds
let _myPointers = {}; // Pointers


/**
 * WebChucK process audio data in the ring buffer with the user-supplied kernel
 *
 * NOTE: This assumes that no one will modify the buffer content while it is
 * processed by this method.
 * 
 * @tzfeng making changes to this
 */
function processKernel() {
  let inputReadIndex = States[STATE.IB_READ_INDEX];
  let outputWriteIndex = States[STATE.OB_WRITE_INDEX];

  if (isNaN(InputRingBuffer[0][inputReadIndex])) {
    console.error('Found NaN at buffer index: %d', inputReadIndex);
  }

  // TODO: @tzfeng hardcoded to channelCount, this might dynamically change in 
  // the web audio node graph
  _heapInputBuffer.adaptChannel( CONFIG.channelCount ); 

  // Single Channel
  // Copy shared input ring buffer into chuck's heap
  if (inputReadIndex + CONFIG.kernelLength < CONFIG.ringBufferLength) {
    // If we can copy the entire kernel from ring buffer
    _heapInputBuffer.getChannelData(0).set(InputRingBuffer[0].subarray(inputReadIndex, inputReadIndex + CONFIG.kernelLength));
    inputReadIndex += CONFIG.kernelLength;
  } else {
    // When we cross the ring buffer boundary and need to wraparound, copy in two parts
    const splitIndex = CONFIG.ringBufferLength - inputReadIndex;
    const firstHalf = InputRingBuffer[0].subarray(inputReadIndex); // index to end
    const secondHalf = InputRingBuffer[0].subarray(0, CONFIG.kernelLength - splitIndex); // beginning to leftover index
    _heapInputBuffer.getChannelData(0).set(firstHalf);
    _heapInputBuffer.getChannelData(0).set(secondHalf, firstHalf.length); // start at end of first half
    inputReadIndex = secondHalf.length;
  }
  // Multi Channel
  // for (let channel = 0; channel < CONFIG.channelCount; ++channel) {
  //   // Copy shared input ring buffer into chuck's heap
  //   if (inputReadIndex + CONFIG.kernelLength < CONFIG.ringBufferLengthSingle) {
  //     // If we can copy the entire kernel from ring buffer
  //     _heapInputBuffer.getChannelData(channel).set(InputRingBuffer[channel].subarray(inputReadIndex, inputReadIndex + CONFIG.kernelLength));
  //     inputReadIndex += CONFIG.kernelLength;
  //   } else {
  //     // When we cross the ring buffer boundary and need to wraparound, copy in two parts
  //     const splitIndex = CONFIG.ringBufferLengthSingle - inputReadIndex;
  //     const firstHalf = InputRingBuffer[channel].subarray(inputReadIndex); // index to end
  //     const secondHalf = InputRingBuffer[channel].subarray(0, CONFIG.kernelLength - splitIndex); // beginning to leftover index
  //     _heapInputBuffer.getChannelData(channel).set(firstHalf);
  //     _heapInputBuffer.getChannelData(channel).set(secondHalf, firstHalf.length); // start at end of first half
  //     inputReadIndex = secondHalf.length;
  //   }
  // }

  // Chuck process input and output buffers 
  _chuckWasmModule._chuckManualAudioCallback(
    CHUCK_ID,        // chuck ID
    _heapInputBuffer.getHeapAddress(),
    _heapOutputBuffer.getHeapAddress(),
    CONFIG.kernelLength, // frame size (probably 1024)
    CONFIG.channelCount, // in channels
    CONFIG.channelCount, // out channels
  );

  _heapOutputBuffer.adaptChannel( CONFIG.channelCount );

  // Single Channel
  // Copy chuck's heap into shared output ring buffer
  if (outputWriteIndex + CONFIG.kernelLength < CONFIG.ringBufferLength) {
    // If we can copy the entire kernel from ring buffer
    OutputRingBuffer[0].set(_heapOutputBuffer.getChannelData(0), outputWriteIndex);
    outputWriteIndex += CONFIG.kernelLength;
  } else {
    // When we cross the ring buffer boundary and need to wraparound, copy in two parts
    const splitIndex = CONFIG.ringBufferLength - outputWriteIndex;
    const firstHalf = _heapOutputBuffer.getChannelData(0).subarray(0, splitIndex);
    const secondHalf = _heapOutputBuffer.getChannelData(0).subarray(splitIndex);
    OutputRingBuffer[0].set(firstHalf, outputWriteIndex);
    OutputRingBuffer[0].set(secondHalf, 0);
    outputWriteIndex = secondHalf.length;
  }
  // Multi Channel
  // for (let channel = 0; channel < CONFIG.channelCount; ++channel) {
  //   // Copy chuck's heap into shared output ring buffer
  //   if (outputWriteIndex + CONFIG.kernelLength < CONFIG.ringBufferLengthSingle) {
  //     // If we can copy the entire kernel from ring buffer
  //     OutputRingBuffer[0].set(_heapOutputBuffer.getChannelData(channel), outputWriteIndex);
  //     outputWriteIndex += CONFIG.kernelLength;
  //   } else {
  //     // When we cross the ring buffer boundary and need to wraparound, copy in two parts
  //     const splitIndex = CONFIG.ringBufferLengthSingle - outputWriteIndex;
  //     const firstHalf = _heapOutputBuffer.getChannelData(0).subarray(0, splitIndex);
  //     const secondHalf = _heapOutputBuffer.getChannelData(0).subarray(splitIndex);
  //     OutputRingBuffer[0].set(firstHalf, outputWriteIndex);
  //     OutputRingBuffer[0].set(secondHalf, 0);
  //     outputWriteIndex = secondHalf.length;
  //   }
  // }

  States[STATE.IB_READ_INDEX] = inputReadIndex;
  States[STATE.OB_WRITE_INDEX] = outputWriteIndex;
}


/**
 * Waits for the signal delivered via |States| SAB. When signaled, webchuck 
 * processes the audio data to fill up |outputRingBuffer|.
 */
async function waitOnRenderRequest() {
  // while (Atomics.wait(States, STATE.REQUEST_RENDER, 0) === 'ok') {
  //   processKernel();
  while (true) {
    // As long as |REQUEST_RENDER| is zero, keep waiting. (sleep)
    const result = Atomics.waitAsync(States, STATE.REQUEST_RENDER, 0);
    await result.value;

    processKernel();

    // Update the number of available frames in the buffer.
    States[STATE.IB_FRAMES_AVAILABLE] -= CONFIG.kernelLength;
    States[STATE.OB_FRAMES_AVAILABLE] += CONFIG.kernelLength;

    // Reset the request render bit, and wait again.
    Atomics.store(States, STATE.REQUEST_RENDER, 0);
  }
}

/**
 * Initialize webchuck worker; allocates SAB, sets up TypedArrayViews, primes
 * |States| buffer and notify the main thread.
 *
 * @param {object} options User-supplied options.
 * @param {File[]} preloadedFiles Preloaded files.
 * @param {ArrayBuffer} wasm WebChucK WASM module.
 */
async function initialize(options, preloadedFiles, wasm) {
  if (options.ringBufferLength) {
    CONFIG.ringBufferLength = options.ringBufferLength;
  }
  if (options.channelCount) {
    CONFIG.channelCount = options.channelCount;
  }
  if (options.srate) {
    CONFIG.sampleRate = options.srate;
  }

  if (!self.SharedArrayBuffer) {
    postMessage({
      message: 'WORKER_ERROR',
      detail: `SharedArrayBuffer is not supported in your browser. See
          https://developers.google.com/web/updates/2018/06/audio-worklet-design-pattern
          for more info.`,
    });
    return;
  }

  // Allocate SABs.
  const SharedBuffers = {
    states: new SharedArrayBuffer(CONFIG.stateBufferLength * CONFIG.bytesPerState),
    inputRingBuffer: new SharedArrayBuffer(CONFIG.ringBufferLength * CONFIG.channelCount * CONFIG.bytesPerSample),
    outputRingBuffer: new SharedArrayBuffer(CONFIG.ringBufferLength * CONFIG.channelCount * CONFIG.bytesPerSample),
  };

  // Get TypedArrayView from SAB.
  // TODO: @tzfeng how to adapt for 2 channels?
  States = new Int32Array(SharedBuffers.states);
  InputRingBuffer = [new Float32Array(SharedBuffers.inputRingBuffer)];
  OutputRingBuffer = [new Float32Array(SharedBuffers.outputRingBuffer)];

  // Initialize |States| buffer.
  Atomics.store(States, STATE.RING_BUFFER_LENGTH, CONFIG.ringBufferLength);
  Atomics.store(States, STATE.KERNEL_LENGTH, CONFIG.kernelLength);

  // Initialize the ChucK WASM module
  // Set up emscripten bindings and globals
  // @tzfeng @azaday
  await initChuckWasm(preloadedFiles, wasm)

  // Notify AWN in the main scope that the worker is ready.
  postMessage({
    message: 'WORKER_READY',
    SharedBuffers: SharedBuffers,
  });

  // Start waiting.
  waitOnRenderRequest();
}


/**
 * Initialize a ChucK Emscripten WASM module
 * Written by @tzfeng @azaday
 */
async function initChuckWasm(preloadedFiles, wasm) {
  // Emscripten Premodule
  let PreModule = {
      wasmBinary: wasm,
      print: (text) => postMessage({ type: "console print", message: text }),
      printErr: (text) => postMessage({ type: "console print", message: text }),
      preRun: () => {
          // Create a directory for chugins
          PreModule["FS_createPath"]("/", "chugins", true, true);
      
          // Preload files into the file system
          preloadedFiles.forEach(file => {
              PreModule["FS_createPreloadedFile"]("/", file.filename, file.data, true, true);
          });
        },
      noAudioDecoding: true,
      noImageDecoding: true
  };

  // Emscripten will now initialize the Chuck WASM
  // After Emscripten initializes...
  _chuckWasmModule = await ChucK(PreModule);

  initGlobals(_chuckWasmModule);
  _heapInputBuffer = new HeapAudioBuffer(_chuckWasmModule, CONFIG.kernelLength, CONFIG.channelCount, MAX_CHANNEL_COUNT);
  _heapOutputBuffer = new HeapAudioBuffer(_chuckWasmModule, CONFIG.kernelLength, CONFIG.channelCount, MAX_CHANNEL_COUNT);

  setLogLevel(3);
  initChuckInstance(CHUCK_ID, CONFIG.sampleRate, CONFIG.channelCount, CONFIG.channelCount);
}


//---------------------------------------------------------------------
// ChucK Helper Functions (actions)
//---------------------------------------------------------------------
function _handleNewShredID(newShredID, shredCallback) {
  if (newShredID > 0) {
    // keep track for myself
    _myActiveShreds.push(newShredID);
  } else {
    // compilation failed
  }
  // tell the host
  postMessage({
    type: "newShredCallback",
    callback: shredCallback,
    shred: newShredID
  });
}

function _handleReplacedShredID( oldShredID, newShredID, shredCallback ) {
  if (newShredID > 0) {
    // keep track for myself
    _myActiveShreds.push(newShredID);
  } else {
    // compilation failed --> we did not actually remove oldShredID
    _myActiveShreds.push(oldShredID);
  }
  // tell the host
  postMessage({
    type: "replacedShredCallback",
    callback: shredCallback,
    newShred: newShredID,
    oldShred: oldShredID
  });
}

function _handleRemoveShred(shredID, callback) {
  if (removeShred(CHUCK_ID, shredID)) {
    _handleRemovedShredID(shredID, callback);
  } else {
    _handleRemovedShredID(0, callback);
  }
}

function _handleRemovedShredID(shredID, shredCallback) {
  postMessage({
    type: "removedShredCallback",
    callback: shredCallback,
    shred: shredID
  });
}

function _findMostRecentActiveShred() {
  // find the most recent shred that is still active,
  // and forget about all the more recently shredded ones
  // that are no longer active
  let shredID = _myActiveShreds.pop();
  while (shredID && !isShredActive(CHUCK_ID, shredID)) {
    shredID = _myActiveShreds.pop();
  }
  return shredID;
}

function _findShredToReplace()
{
  let shredToReplace = _findMostRecentActiveShred();
  if (!shredToReplace) {
    postMessage({
      type: "console print",
      message: "[chuck](VM): no shreds to replace..."
    });
  }
  return shredToReplace;
}


//---------------------------------------------------------------------
// Message Handling from Chuck.ts (Main Thread)
//---------------------------------------------------------------------
/**
 * Handle messages from the main thread to worker (us)
 */
onmessage = async (eventFromMain) => {
  if (eventFromMain.data.message === 'INITIALIZE_WORKER') {
    await initialize(eventFromMain.data.options, eventFromMain.data.options.preloadedFiles, eventFromMain.data.options.wasm);
    return;
  }

  // WebChucK API action messages
  handle_message(eventFromMain);
};

/**
 * Handles WebChucK API messages from main thread
 * @param {*} event 
 */
function handle_message(event) {
  switch (event.data.type) {
    // ================== Filesystem ===================== //
    case 'createFile':
      _chuckWasmModule.FS_createDataFile('/' + event.data.directory,
        event.data.filename, event.data.data, true, true, true);
      break;
    // ================== Run / Compile ================== //
    case 'runChuckCode': {
      const shredID = runChuckCode(CHUCK_ID, event.data.code);
      _handleNewShredID(shredID, event.data.callback);
      break;
    }
    case 'runChuckCodeWithReplacementDac': {
      const shredID = runChuckCodeWithReplacementDac(CHUCK_ID, event.data.code, event.data.dac_name);
      _handleNewShredID(shredID, event.data.callback);
      break;
    }
    case 'runChuckFile': {
      const shredID = runChuckFile(CHUCK_ID, event.data.filename);
      _handleNewShredID(shredID, event.data.callback);
      break;
    }
    case 'runChuckFileWithReplacementDac': {
      const shredID = runChuckFileWithReplacementDac(CHUCK_ID, event.data.filename, event.data.dac_name);
      _handleNewShredID(shredID, event.data.callback);
      break;
    }
    case 'runChuckFileWithArgs': {
      const shredID = runChuckFileWithArgs(CHUCK_ID, event.data.filename, event.data.colon_separated_args);
      _handleNewShredID(shredID, event.data.callback);
      break;
    }
    case 'runChuckFileWithArgsWithReplacementDac': {
      const shredID = runChuckFileWithArgsWithReplacementDac(CHUCK_ID, event.data.filename, event.data.colon_separated_args, event.data.dac_name);
      _handleNewShredID(shredID, event.data.callback);
      break;
    }
    case 'replaceChuckCode': {
      const shredToReplace = _findShredToReplace();
      if (shredToReplace) {
        let shredID = replaceChuckCode(CHUCK_ID, shredToReplace, event.data.code);
        _handleReplacedShredID(shredToReplace, shredID, event.data.callback);
      }
      break;
    }
    case 'replaceChuckCodeWithReplacementDac': {
      const shredToReplace = _findShredToReplace();
      if (shredToReplace) {
        const shredID = replaceChuckCodeWithReplacementDac(CHUCK_ID, shredToReplace, event.data.code, event.data.dac_name);
        _handleReplacedShredID(shredToReplace, shredID, event.data.callback);
      }
      break;
    }
    case 'replaceChuckFile': {
      const shredToReplace = _findShredToReplace();
      if (shredToReplace) {
        const shredID = replaceChuckFile(CHUCK_ID, shredToReplace, event.data.filename);
        _handleReplacedShredID(shredToReplace, shredID, event.data.callback);
      }
      break;
    }
    case 'replaceChuckFileWithReplacementDac': {
      const shredToReplace = _findShredToReplace();
      if (shredToReplace) {
        const shredID = replaceChuckFileWithReplacementDac(CHUCK_ID, shredToReplace, event.data.filename, event.data.dac_name);
        _handleReplacedShredID(shredToReplace, shredID, event.data.callback);
      }
      break;
    }
    case 'replaceChuckFileWithArgs': {
      const shredToReplace = _findShredToReplace();
      if (shredToReplace) {
        const shredID = replaceChuckFileWithArgs(CHUCK_ID, shredToReplace, event.data.filename, event.data.colon_separated_args);
        _handleReplacedShredID(shredToReplace, shredID, event.data.callback);
      }
      break;
    }
    case 'replaceChuckFileWithArgsWithReplacementDac': {
      const shredToReplace = _findShredToReplace();
      if (shredToReplace) {
        const shredID = replaceChuckFileWithArgsWithReplacementDac(CHUCK_ID, shredToReplace, event.data.filename, event.data.colon_separated_args, event.data.dac_name);
        _handleReplacedShredID(shredToReplace, shredID, event.data.callback);
      }
      break;
    }
    case 'removeLastCode': {
      const shredID = _findMostRecentActiveShred();
      // if we found a shred, remove it, otherwise,
      // there are no shreds left to remove
      if (shredID) {
        _handleRemoveShred(shredID, event.data.callback);
      } else {
        postMessage({
          type: "console print",
          message: "[chuck](VM): no shreds to remove..."
        });
      }
      break;
    }
    case 'removeShred': {
      _handleRemoveShred(event.data.shred, event.data.callback);
      break;
    }
    case 'isShredActive': {
      postMessage({
        type: "intCallback",
        callback: event.data.callback,
        result: isShredActive(CHUCK_ID, event.data.shred)
      });
      break;
    }
    // ================== Int, Float, String ============= //
    case 'setChuckInt': {
      setChuckInt(CHUCK_ID, event.data.variable, event.data.value);
      break;
    }
    case 'getChuckInt': {
      const result = getChuckInt(CHUCK_ID, event.data.variable);
      postMessage({ type: "intCallback", callback: event.data.callback, result: result });
      break;
    }
    case 'setChuckFloat': {
      setChuckFloat(CHUCK_ID, event.data.variable, event.data.value);
      break;
    }
    case 'getChuckFloat': {
      const result = getChuckFloat(CHUCK_ID, event.data.variable);
      postMessage({ type: "floatCallback", callback: event.data.callback, result: result });
      break;
    }
    case 'setChuckString': {
      setChuckString(CHUCK_ID, event.data.variable, event.data.value);
      break;
    }
    case 'getChuckString': {
      // (function (thePort, theCallback, theVariable, theID, Module) {
      //   let pointer = _chuckWasmModule.addFunction((function (thePort, theCallback) {
      //     return function (string_ptr) {
      //       thePort.postMessage({
      //         type: "stringCallback",
      //         callback: theCallback,
      //         result: Module.UTF8ToString(string_ptr)
      //       });
      //       Module.removeFunction(pointer);
      //     }
      //   })(thePort, theCallback), 'vi');
      //   getChuckString(theID, theVariable, pointer);
      // })(this.port, event.data.callback, event.data.variable, CHUCK_ID, this.Module);
      // break;
      const { callback, variable } = event.data;
      const pointer = _chuckWasmModule.addFunction((string_ptr) => {
        postMessage({
          type: "stringCallback",
          callback,
          result: _chuckWasmModule.UTF8ToString(string_ptr)
        });
        _chuckWasmModule.removeFunction(pointer);
      }, 'vi');
      getChuckString(CHUCK_ID, variable, pointer);
      break;
    }
    // ================== Event =================== //
    case 'signalChuckEvent': {
      signalChuckEvent(CHUCK_ID, event.data.variable);
      break;
    }
    case 'broadcastChuckEvent': {
      broadcastChuckEvent(CHUCK_ID, event.data.variable);
      break;
    }
    case 'listenForChuckEventOnce': {
      // (function (thePort, theCallback, theVariable, theID, Module) {
      //   let pointer = Module.addFunction((function (thePort, theCallback) {
      //     return function () {
      //       thePort.postMessage({ type: "eventCallback", callback: theCallback });
      //       Module.removeFunction(pointer);
      //     }
      //   })(thePort, theCallback), 'v');
      //   listenForChuckEventOnce(theID, theVariable, pointer);
      // })(this.port, event.data.callback, event.data.variable, CHUCK_ID, this.Module);
      // break;
      const { callback, variable } = event.data;
      const pointer = _chuckWasmModule.addFunction(() => {
        postMessage({ type: "eventCallback", callback });
        _chuckWasmModule.removeFunction(pointer);
      }, 'v');
      listenForChuckEventOnce(CHUCK_ID, variable, pointer);
      break;
    }
    case 'startListeningForChuckEvent': {
      // this.myPointers[event.data.callback] = this.Module.addFunction((function (thePort, theCallback) {
      //   return function () {
      //     thePort.postMessage({ type: "eventCallback", callback: theCallback });
      //   }
      // })(this.port, event.data.callback), 'v');
      // startListeningForChuckEvent(CHUCK_ID, event.data.variable, this.myPointers[event.data.callback]);
      // break;
      const { callback, variable } = event.data;
      _myPointers[callback] = _chuckWasmModule.addFunction(() => {
        postMessage({ type: "eventCallback", callback });
      }, 'v');
      startListeningForChuckEvent(CHUCK_ID, variable, _myPointers[callback]);
      break;
    }
    case 'stopListeningForChuckEvent': {
      stopListeningForChuckEvent(CHUCK_ID, event.data.variable, _myPointers[event.data.callback]);
      _chuckWasmModule.removeFunction(_myPointers[event.data.callback]);
      break;
    }
    // ================== Int[] =================== //
    case 'setGlobalIntArray': {
      // convert to Int32Array
      const values = new Int32Array(event.data.values);
      // put onto heap
      const valuesPtr = _chuckWasmModule._malloc(values.length * values.BYTES_PER_ELEMENT);
      const heapview = _chuckWasmModule.HEAP32.subarray((valuesPtr >> 2), (valuesPtr >> 2) + values.length);
      heapview.set(values);

      // put variable name on heap as well
      const stringBytes = event.data.variable.length << 2 + 1;
      const stringPtr = _chuckWasmModule._malloc(stringBytes);
      _chuckWasmModule.stringToUTF8(event.data.variable, stringPtr, stringBytes);

      // call
      _chuckWasmModule._setGlobalIntArray(CHUCK_ID, stringPtr, valuesPtr, values.length);

      // free
      _chuckWasmModule._free(valuesPtr);
      _chuckWasmModule._free(stringPtr);
      break;
    }
    case 'getGlobalIntArray': {
      // (function (thePort, theCallback, theVariable, theID, Module) {
      //   let pointer = Module.addFunction((function (thePort, theCallback) {
      //     return function (int32_ptr, len) {
      //       let result = new Int32Array(
      //         Module.HEAPU8.buffer,
      //         int32_ptr,
      //         len
      //       );
      //       thePort.postMessage({
      //         type: "intArrayCallback",
      //         callback: theCallback,
      //         result: Array.from(result)
      //       });
      //       Module.removeFunction(pointer);
      //     }
      //   })(thePort, theCallback), 'vii');
      //   getGlobalIntArray(theID, theVariable, pointer);
      // })(this.port, event.data.callback, event.data.variable, CHUCK_ID, this.Module);
      // break;
      const { callback, variable } = event.data;
      const pointer = _chuckWasmModule.addFunction((int32_ptr, len) => {
        const result = new Int32Array(
          _chuckWasmModule.HEAPU8.buffer,
          int32_ptr,
          len
        );
        postMessage({
          type: "intArrayCallback",
          callback,
          result: Array.from(result)
        });
        _chuckWasmModule.removeFunction(pointer);
      }, 'vii');
      getGlobalIntArray(CHUCK_ID, variable, pointer);
      break;
    }
    case 'setGlobalIntArrayValue': {
      setGlobalIntArrayValue(CHUCK_ID, event.data.variable, event.data.index, event.data.value);
      break;
    }
    case 'getGlobalIntArrayValue': {
      const result = getGlobalIntArrayValue(CHUCK_ID, event.data.variable, event.data.index);
      postMessage({ type: "intCallback", callback: event.data.callback, result: result });
      break;
    }
    case 'setGlobalAssociativeIntArrayValue': {
      setGlobalAssociativeIntArrayValue(CHUCK_ID, event.data.variable, event.data.key, event.data.value);
      break;
    }
    case 'getGlobalAssociativeIntArrayValue': {
      const result = getGlobalAssociativeIntArrayValue(CHUCK_ID, event.data.variable, event.data.key);
      postMessage({ type: "intCallback", callback: event.data.callback, result: result });
      break;
    }
    // ================== Float[] =================== //
    case 'setGlobalFloatArray': {
      // convert to Float64Array
      const values = new Float64Array(event.data.values);
      // put onto heap
      const valuesPtr = _chuckWasmModule._malloc(values.length * values.BYTES_PER_ELEMENT);
      const heapview = _chuckWasmModule.HEAPF64.subarray((valuesPtr >> 3), (valuesPtr >> 3) + values.length);
      heapview.set(values);

      // put variable name on heap as well
      const stringBytes = event.data.variable.length << 2 + 1;
      const stringPtr = _chuckWasmModule._malloc(stringBytes);
      _chuckWasmModule.stringToUTF8(event.data.variable, stringPtr, stringBytes);

      // call
      _chuckWasmModule._setGlobalFloatArray(CHUCK_ID, stringPtr, valuesPtr, values.length);

      // free
      _chuckWasmModule._free(valuesPtr);
      _chuckWasmModule._free(stringPtr);
      break;
    }
    case 'getGlobalFloatArray': {
      // (function (thePort, theCallback, theVariable, theID, Module) {
      //   let pointer = Module.addFunction((function (thePort, theCallback) {
      //     return function (float64_ptr, len) {
      //       let result = new Float64Array(
      //         Module.HEAPU8.buffer,
      //         float64_ptr,
      //         len
      //       );
      //       thePort.postMessage({
      //         type: "floatArrayCallback",
      //         callback: theCallback,
      //         result: Array.from(result)
      //       });
      //       Module.removeFunction(pointer);
      //     }
      //   })(thePort, theCallback), 'vii');
      //   getGlobalFloatArray(theID, theVariable, pointer);
      // })(this.port, event.data.callback, event.data.variable, CHUCK_ID, this.Module);
      // break;
      const { callback, variable } = event.data;
      const pointer = _chuckWasmModule.addFunction((float64_ptr, len) => {
        const result = new Float64Array(
          _chuckWasmModule.HEAPU8.buffer,
          float64_ptr,
          len
        );
        postMessage({
          type: "floatArrayCallback",
          callback,
          result: Array.from(result)
        });
        _chuckWasmModule.removeFunction(pointer);
      }, 'vii');
      getGlobalFloatArray(CHUCK_ID, variable, pointer);
      break;
    }
    case 'setGlobalFloatArrayValue': {
      setGlobalFloatArrayValue(CHUCK_ID, event.data.variable, event.data.index, event.data.value);
      break;
    }
    case 'getGlobalFloatArrayValue': {
      const result = getGlobalFloatArrayValue(CHUCK_ID, event.data.variable, event.data.index);
      postMessage({ type: "floatCallback", callback: event.data.callback, result: result });
      break;
    }
    case 'setGlobalAssociativeFloatArrayValue': {
      setGlobalAssociativeFloatArrayValue(CHUCK_ID, event.data.variable, event.data.key, event.data.value);
      break;
    }
    case 'getGlobalAssociativeFloatArrayValue': {
      const result = getGlobalAssociativeFloatArrayValue(CHUCK_ID, event.data.variable, event.data.key);
      postMessage({ type: "floatCallback", callback: event.data.callback, result: result });
      break;
    }
    // ==================== VM Param Functions ======================
    // 1.5.0.8 (ge) added
    case 'setParamInt': {
      setParamInt(CHUCK_ID, event.data.name, event.data.value);
      break;
    }
    case 'getParamInt': {
      const result = getParamInt(CHUCK_ID, event.data.name);
      postMessage({ type: "intCallback", callback: event.data.callback, result: result });
      break;
    }
    case 'setParamFloat': {
      setParamFloat(CHUCK_ID, event.data.name, event.data.value);
      break;
    }
    case 'getParamFloat': {
      const result = getParamFloat(CHUCK_ID, event.data.name);
      postMessage({ type: "floatCallback", callback: event.data.callback, result: result });
      break;
    }
    case 'setParamString': {
      setParamString(CHUCK_ID, event.data.name, event.data.value);
      break;
    }
    case 'getParamString': {
      const result = getParamString(CHUCK_ID, event.data.name);
      postMessage({ type: "stringCallback", callback: event.data.callback, result: result });
      break;
    }
    // ==================== VM Functions ====================== //
    case 'now':
    case 'getChuckNow': {
      const result = getChuckNow(CHUCK_ID);
      postMessage({ type: "floatCallback", callback: event.data.callback, result: result });
      break;
    }
    case 'clearChuckInstance': {
      clearChuckInstance(CHUCK_ID);
      break;
    }
    case 'clearGlobals': {
      clearGlobals(CHUCK_ID);
      postMessage({
        type: "console print",
        message: "[chuck](VM): resetting all global variables"
      });
      break;
    }
    default:
      postMessage({
        type: "console error",
        message: "webchuck unknown message"
      })
      break;
  }
}
